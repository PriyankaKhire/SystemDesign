<h1>Instagram Sharding</h1>
  <p>This article is my understanding of <a href="https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c">Sharding & IDs at Instagram</a> </p>
  <p><b>TLDR</b>: They use logical shards (Postgres has inbuilt functionality for this). Shard ID is following: EpochTime-ShardID-AutoIncrementingSequence. The IDs are created by postgres tables.</p>
  <h2>Capacity Estimations</h2>
    <p>More than 25 photos and 90 likes every second.</p>
    <p>
      Total seconds in a day 86400 <br/>
      Max Size of one instagram image 30MB <br/>
      Total data storage required in a day 86400 X 25 X 30MB = 64.8 TB
    </p>
  <h2>Main Goal</h2>
    <ul>
      <li>How to assign unique identifiers to each piece of data in the database ?</li>
    </ul>
  <h2>Functional Requirements</h2>
    <ul>
      <li>Generated IDs should be sortable by time</li>
      <li>Max size of the IDs can be up to <b>64 bits</b></li>
      <li>The system should introduce as few <u>new moving parts</u> (new micro-services) as possible.</li>
    </ul>
  <h2>Existing Solutions</h2>
    <h3>Generate IDs in web application</h3>
      <p>The IDs are generated by your web application and not by DB.</p>
      <h4>Pros</h4>
        <ul>
          <li>Each application thread generates IDs independently, minimizing points of failure</li>
          <li>If you use a timestamp as the first component of the ID, the IDs remain time-sortable</li>
        </ul>
      <h4>Cons</h4>
        <ul>
          <li>Requires more than 64 bits space to make sure that the IDs are unique.</li>
        </ul>
    <h3>Generate IDs through dedicated service</h3>
      <h4>Pros</h4>
        <ul>
          <li>Can have ID size upto 64 bits</li>
          <li>Can use time as first component of the ID thus making it easy to sort by time</li>
          <li>Can make it into distributed system so no single point of failure.</li>
        </ul>
      <h4>Cons</h4>
        <ul>
          <li>Will introduce a "new moving part", therefore adding to complexity of the overall system.</li>
        </ul>
      <h4>Who uses this approach</h4>
        <p><a href="https://github.com/twitter-archive/snowflake">Twitter’s Snowflake</a>, a Thrift service that uses Apache ZooKeeper to coordinate nodes and then generates 64-bit unique IDs</p>
    <h3>DB Ticket Servers</h3>
      <p>DB generates the IDs and we use the DBs auto-incrementing abilities to force uniqueness.</p>
      <h4>Pros</h4>
        <ul><li>DBs can be scaled easily.</li></ul>
      <h4>Cons</h4>
        <ul>
          <li>If we use single DB, it can become single point of failure. If we use multiple DBs and because of asynchronous inserts, it cannot be sorted by time (because multiple pictures can have same time stamp) plus it can become complicated to manage all the DBs.</li>
          <li>Requires additional EC2 instances to admin (I didn't understand this point)</li>
        </ul>
      <h4>Who uses this approach</h4>
        <p><a href="https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/">Flicker</a> </p>
  <h2>Solution</h2>
    <ul>
      <li>Create <b>Logical Shards</b> that are mapped to few physical shards, thus we can start with few DB servers to begin with.
        <ul>
          <li>Each ‘logical’ shard is a Postgres <b>schema</b>
            <ul>
              <li><b>Do not</b> confuse Postgres Schema to SQL schema of an individual table.</li>
              <li>Schemas are logical grouping feature in Postgres.</li>
              <li>Each Postgres DB can have several schemas that can contain one or more tables.</li>
              <li>Table names need to be unique per schema and not per DB server.</li>
            </ul>
          </li>
          <li>Each sharded table (for example, likes on our photos) exists inside each schema</li>
        </ul>
      </li>
      <li>Scaling is easy because of the logical shards. If we add more DB servers, we just have to move these logical shards from one server to another without having to re-bucket the data. Postgres has inbuilt feature to do this.</li>
      <li>IDs are created by tables inside each logical shard. (Postgres has inbuilt feature to do this)</li>
      <li>Each of the IDs consist of:
        <ol>
          <li>41 bits for time in milliseconds (gives us 41 years of IDs with a custom epoch)</li>
          <li>13 bits that represent the logical shard ID</li>
          <li>10 bits that represent an auto-incrementing sequence</li>
        </ol>
        Thus we can generate 1024 IDs, per shard, per millisecond.
      </li>
    </ul>